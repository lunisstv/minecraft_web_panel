<!DOCTYPE html>
<html lang="de"> <!-- Klasse 'dark-mode' wird hier per JS gesetzt -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Server Panel</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script>
        // Initialen Dark Mode basierend auf localStorage oder OS-Präferenz setzen
        (function() {
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const storedTheme = localStorage.getItem('theme');
            if (storedTheme === 'dark' || (!storedTheme && prefersDark)) {
                document.documentElement.classList.add('dark-mode');
            } else {
                document.documentElement.classList.remove('dark-mode');
            }
        })();
    </script>
</head>
<body class=""> <!-- Klasse 'dark-mode' wird hier auch dynamisch per JS gesetzt/entfernt -->
    <div class="main-container">
        <header class="panel-header">
            <h1>Server Panel</h1>
            <div style="display: flex; align-items: center; gap: 20px;">
                {% if logged_in_user %}
                    <div class="user-info">
                        Eingeloggt als: <strong>{{ logged_in_user }}</strong><br>
                        <a href="{{ url_for('logout_route') }}" class="button">Logout</a>
                    </div>
                {% endif %}
                <div class="theme-switch-wrapper">
                    <label class="theme-switch" for="theme-checkbox" title="Dark Mode umschalten">
                        <input type="checkbox" id="theme-checkbox" />
                        <div class="slider"></div>
                    </label>
                    <span id="theme-label" style="display:none;">Dark Mode</span>
                </div>
            </div>
        </header>

        <div class="messages-container">
             <div id="message" class="message" style="display:none;"></div>
            {% with messages = get_flashed_messages(with_categories=true) %}
                {% if messages %}
                    {% for category, message_text in messages %}
                        <div class="message {{ category }}">{{ message_text }}</div>
                    {% endfor %}
                {% endif %}
            {% endwith %}
        </div>

        <section class="card">
            <h2>Server Instanzen</h2>
            <div class="instance-list">
                <table>
                    <thead>
                        <tr>
                            <th>Instanzname</th>
                            <th>Status</th>
                            <th>Port</th>
                            <th style="width: 300px;">Aktionen</th>
                        </tr>
                    </thead>
                    <tbody id="instanceTableBody">
                        <tr><td colspan="4" style="text-align:center; padding: 30px; color: var(--text-color-tertiary);">Lade Instanzen...</td></tr>
                    </tbody>
                </table>
            </div>
            <button onclick="refreshStatuses()" style="margin-top: 20px;">Status Aktualisieren</button>
        </section>

        <section class="card">
            <h2>Neue Server-Instanz / Konfiguration Ändern</h2>
            <form id="serverForm">
                <label for="instance_name">Instanzname:</label>
                <input type="text" id="instance_name" name="instance_name" placeholder="z.B. survival_120" required>
                <p class="form-hint">Ordner: <code>{{ default_instance_path }}/[Instanzname]</code>. Überschreibt bestehende Konfig.</p>

                <label for="server_jar">Server Version (JAR):</label>
                <select id="server_jar" name="server_jar" required>
                    <option value="">-- Wähle JAR --</option>
                    {% for jar in server_jars %}
                        <option value="{{ jar }}">{{ jar }}</option>
                    {% endfor %}
                </select>
                {% if not server_jars %}
                <p class="message warning">Keine Server-JARs in <code>{{ macros.SERVER_VERSIONS_BASE_PATH if macros else '/opt/minecraft_versions' }}</code> gefunden!</p>
                {% endif %}

                <div style="display: flex; gap: 20px; margin-top:15px;">
                    <div style="flex: 1;">
                        <label for="min_ram">Min. RAM:</label>
                        <input type="text" id="min_ram" name="min_ram" value="1G" placeholder="z.B. 1G">
                    </div>
                    <div style="flex: 1;">
                        <label for="max_ram">Max. RAM:</label>
                        <input type="text" id="max_ram" name="max_ram" value="2G" placeholder="z.B. 2G">
                    </div>
                </div>

                <label for="velocity_secret">Velocity Secret Key (optional):</label>
                <input type="password" id="velocity_secret" name="velocity_secret" placeholder="Leer lassen, wenn nicht benötigt">

                <label for="java_args">Zusätzliche Java Argumente (optional):</label>
                <textarea id="java_args" name="java_args" placeholder="Standard: Aikar's Flags"></textarea>
                <p class="form-hint">Überschreibt Standard Aikar's Flags, wenn nicht leer.</p>

                <label for="server_args">Zusätzliche Server Argumente:</label>
                <input list="server_args_suggestions" type="text" id="server_args" name="server_args" value="nogui" placeholder="Standard: nogui">
                <datalist id="server_args_suggestions">
                    <option value="nogui"></option>
                    <option value="--nogui"></option>
                    <option value="--port 25566"></option>
                    <option value="--world MEINE_WELT_ORDNERNAME"></option>
                    <option value="--forceUpgrade"></option>
                    <option value="--eraseCache"></option>
                    <option value="--bonusChest"></option>
                    <option value="--jfrProfile"></option>
                    <option value="--serverId YOUR_SERVER_ID"></option> <!-- Für z.B. Velocity -->
                    <option value="--maxPlayers 20"></option>
                    <option value="--online-mode true"></option>
                    <option value="--online-mode false"></option>
                </datalist>
                <p class="form-hint">Standard: nogui. Beginne zu tippen für Vorschläge.</p>

                <h3 style="margin-top: 25px; font-size: 1.2em;">RCON Konfiguration (optional)</h3>
                <p class="form-hint">Erfordert <code>enable-rcon=true</code> in <code>server.properties</code> der Instanz.</p>
                <div style="display: flex; gap: 20px;">
                     <div style="flex: 1;">
                        <label for="rcon_port">RCON Port:</label>
                        <input type="text" id="rcon_port" name="rcon_port" placeholder="{{ default_rcon_port }}">
                    </div>
                    <div style="flex: 1;">
                        <label for="rcon_password">RCON Passwort:</label>
                        <input type="password" id="rcon_password" name="rcon_password" placeholder="Erforderlich, wenn Port gesetzt">
                    </div>
                </div>

                <div style="margin-top: 25px;">
                    <label for="use_screen" class="checkbox-label">
                        <input type="checkbox" id="use_screen" name="use_screen" checked>
                        In Screen-Session starten?
                    </label>
                </div>
                <div id="screen_name_group" style="display: block; margin-top: 10px;">
                     <label for="screen_name">Screen-Name (optional, wenn aktiv):</label>
                     <input type="text" id="screen_name" name="screen_name" placeholder="Standard: mc_[Instanzname]">
                </div>
                <button type="submit" id="startServerButton" style="margin-top: 25px;">Server Starten / Konfiguration Speichern</button>
            </form>
        </section>
    </div>

    <!-- Log Modal -->
    <div id="logModal">
        <div id="logModalContentWrapper">
            <div id="logModalHeader">
                <h3 id="logModalTitle">Server Logs</h3>
                <div class="log-controls">
                    <label for="liveLogToggle"><input type="checkbox" id="liveLogToggle">Live-Update</label>
                    <button onclick="manualLogReload()" class="action-btn secondary">Manuell Neu Laden</button>
                    <button class="close-button" onclick="closeLogModal()" title="Schließen">×</button>
                </div>
            </div>
            <div id="logOutputContainer">
                <pre id="logOutput"></pre>
            </div>
            <div id="rconInputArea">
                <input type="text" id="rconCommandInput" placeholder="RCON Befehl (z.B. say Hallo)">
                <button onclick="sendRconCommand()" class="action-btn">Senden</button>
                <pre id="rconResponseOutput"></pre>
            </div>
        </div>
    </div>

    <script>
        // --- Globale Variablen und Selektoren ---
        const serverForm = document.getElementById('serverForm');
        const messageDiv = document.getElementById('message');
        const instanceNameInput = document.getElementById('instance_name');
        const screenNameInput = document.getElementById('screen_name');
        const useScreenCheckbox = document.getElementById('use_screen');
        const screenNameGroup = document.getElementById('screen_name_group');
        const startServerButton = document.getElementById('startServerButton');

        const logModal = document.getElementById('logModal');
        const logOutputEl = document.getElementById('logOutput');
        const logModalTitleEl = document.getElementById('logModalTitle');
        const liveLogToggleEl = document.getElementById('liveLogToggle');
        
        const rconInputArea = document.getElementById('rconInputArea');
        const rconCommandInput = document.getElementById('rconCommandInput');
        const rconResponseOutput = document.getElementById('rconResponseOutput');
        const logOutputContainer = document.getElementById('logOutputContainer');

        let currentLogViewInstanceName = null;
        let logEventSource = null;
        let autoScrollLogs = true;

        // --- Dark Mode Toggle Logik ---
        const themeCheckbox = document.getElementById('theme-checkbox');
        const currentHtml = document.documentElement;
        const currentBody = document.body;

        function applyTheme(theme) {
            if (theme === 'dark') {
                currentHtml.classList.add('dark-mode');
                currentBody.classList.add('dark-mode');
                if(themeCheckbox) themeCheckbox.checked = true;
            } else {
                currentHtml.classList.remove('dark-mode');
                currentBody.classList.remove('dark-mode');
                if(themeCheckbox) themeCheckbox.checked = false;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const storedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

            if (storedTheme) {
                applyTheme(storedTheme);
            } else if (prefersDark) {
                applyTheme('dark');
            } else {
                applyTheme('light');
            }

            if (themeCheckbox) {
                themeCheckbox.addEventListener('change', function(event) {
                    const newTheme = event.target.checked ? 'dark' : 'light';
                    applyTheme(newTheme);
                    localStorage.setItem('theme', newTheme);
                });
            }
            
            refreshStatuses();
            setInterval(refreshStatuses, 10000);
        });
        
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (!localStorage.getItem('theme')) {
                applyTheme(event.matches ? 'dark' : 'light');
            }
        });

        // --- Hilfsfunktionen ---
        function displayMessage(text, type = 'info') {
            messageDiv.textContent = text;
            messageDiv.className = `message ${type}`;
            setTimeout(() => {
                messageDiv.textContent = '';
                messageDiv.className = 'message';
            }, 7000);
        }

        function sanitizeForScreen(name) {
            return name.replace(/[^a-zA-Z0-9_.-]/g, '_').replace(/\./g, '_');
        }

        // --- Event Listener für Hauptformular ---
        instanceNameInput.addEventListener('input', function() {
            if (screenNameInput.value === '' || screenNameInput.value.startsWith('mc_')) {
                 screenNameInput.value = `mc_${sanitizeForScreen(this.value)}`;
            }
        });
        useScreenCheckbox.addEventListener('change', function() {
            screenNameGroup.style.display = this.checked ? 'block' : 'none';
        });
        screenNameGroup.style.display = useScreenCheckbox.checked ? 'block' : 'none';

        serverForm.addEventListener('submit', async function(event) {
            event.preventDefault();
            startServerButton.disabled = true;
            startServerButton.textContent = "Verarbeite...";
            const formData = new FormData(serverForm);
            try {
                const response = await fetch('/start_server', { method: 'POST', body: formData });
                const result = await response.json();
                displayMessage(result.message, result.status);
                // if (result.status === 'success') serverForm.reset(); // Optional: Formular zurücksetzen
            } catch (error) {
                displayMessage('Netzwerkfehler: ' + error.message, 'error');
            } finally {
                startServerButton.disabled = false;
                startServerButton.textContent = "Server Starten / Konfiguration Speichern";
                refreshStatuses();
            }
        });

        // --- Log Modal & RCON Funktionen ---
        function openLogModal(instanceName, isRconAvailable) {
            currentLogViewInstanceName = instanceName;
            logModalTitleEl.textContent = `Logs für: ${instanceName}`;
            logOutputEl.textContent = 'Lade Logs...';
            logModal.classList.add('active');
            liveLogToggleEl.checked = false; 

            if (isRconAvailable) {
                rconInputArea.style.display = 'flex';
                rconCommandInput.value = '';
                rconResponseOutput.textContent = '';
            } else {
                rconInputArea.style.display = 'none';
            }
            fetchInstanceLogs(true, true);
        }
        
        function manualLogReload() {
            if(currentLogViewInstanceName) {
                liveLogToggleEl.checked = false;
                fetchInstanceLogs(false, true);
            }
        }

        async function fetchInstanceLogs(isInitialLoad = false, forceSnapshot = false) {
            if (!currentLogViewInstanceName) return;
            if (logEventSource) { logEventSource.close(); logEventSource = null; }

            if (liveLogToggleEl.checked && !forceSnapshot) {
                startLogStream(isInitialLoad);
            } else {
                try {
                    const response = await fetch(`/get_logs/${currentLogViewInstanceName}?lines=500`);
                    const data = await response.json();
                    if (isInitialLoad || forceSnapshot) logOutputEl.innerHTML = '';
                    if (response.ok && !data.error) {
                        appendLogLines(data.logs);
                    } else {
                        appendLogLines(`Fehler beim Laden der Logs. Status: ${response.status}\n${data.logs || ''}\n`);
                    }
                } catch (error) {
                    appendLogLines('Netzwerkfehler beim Abrufen der Logs: ' + error.message + '\n');
                }
            }
            if (isInitialLoad || forceSnapshot) scrollToLogBottom();
        }

        function startLogStream(isInitialLoad) {
            if (!currentLogViewInstanceName) return;
            if (logEventSource) { logEventSource.close(); logEventSource = null; }
            if (isInitialLoad) logOutputEl.innerHTML = 'Verbinde zum Log-Stream...\n';
            
            logEventSource = new EventSource(`/stream_logs/${currentLogViewInstanceName}`);
            logEventSource.onmessage = function(event) {
                const newLines = event.data.replace(/\\n/g, '\n');
                appendLogLines(newLines);
            };
            logEventSource.onerror = function(err) {
                appendLogLines("\n[Log-Stream Fehler oder Verbindung geschlossen]\n");
                console.error("EventSource failed:", err);
                if (logEventSource) logEventSource.close();
                liveLogToggleEl.checked = false;
            };
        }

        function appendLogLines(logText) {
            const lines = logText.split('\n');
            lines.forEach((line, index) => {
                if (index === lines.length - 1 && line === '' && !logText.endsWith('\n')) return;
                const span = document.createElement('span');
                if (line.toLowerCase().includes('[error]') || line.toLowerCase().includes(' severe ')) span.className = 'log-line-error';
                else if (line.toLowerCase().includes('[warn]') || line.toLowerCase().includes(' warning ')) span.className = 'log-line-warn';
                span.textContent = line + '\n';
                logOutputEl.appendChild(span);
            });
            if(autoScrollLogs) scrollToLogBottom();
        }

        function scrollToLogBottom() { 
            if(logOutputContainer) logOutputContainer.scrollTop = logOutputContainer.scrollHeight; 
        }
        if(logOutputContainer) {
            logOutputContainer.addEventListener('scroll', function() { 
                autoScrollLogs = (this.scrollTop + this.clientHeight >= this.scrollHeight - 20);
            });
        }
        
        liveLogToggleEl.addEventListener('change', function() { 
            fetchInstanceLogs(false, !this.checked); 
        });
        
        function closeLogModal() {
            logModal.classList.remove('active'); 
            if (logEventSource) { logEventSource.close(); logEventSource = null; }
            currentLogViewInstanceName = null; 
            logOutputEl.innerHTML = ''; 
            rconInputArea.style.display = 'none';
        }

        async function sendRconCommand() {
            if (!currentLogViewInstanceName) return;
            const command = rconCommandInput.value.trim();
            if (!command) { 
                rconResponseOutput.textContent = 'Bitte Befehl eingeben.'; 
                rconResponseOutput.style.color = 'var(--warning-color)'; return; 
            }
            rconResponseOutput.textContent = 'Sende...'; rconResponseOutput.style.color = 'var(--text-color-tertiary)';
            const formData = new FormData(); formData.append('command', command);
            try {
                const response = await fetch(`/send_rcon_command/${currentLogViewInstanceName}`, { method: 'POST', body: formData });
                const result = await response.json();
                if (result.status === 'success') {
                    let formattedResponse = `> ${result.command}\n< ${result.response || '(Keine Server-Antwort)'}`;
                    formattedResponse = formattedResponse.replace(/§[0-9a-fk-or]/g, '');
                    rconResponseOutput.textContent = formattedResponse; rconCommandInput.value = '';
                    appendLogLines(`[RCON] ${formattedResponse.replace(/\n/g, '\n[RCON] ')}\n`);
                } else { 
                    rconResponseOutput.textContent = `RCON Fehler: ${result.message}`; 
                    rconResponseOutput.style.color = 'var(--destructive-color)'; 
                }
            } catch (error) { 
                rconResponseOutput.textContent = 'Netzwerkfehler RCON: ' + error.message; 
                rconResponseOutput.style.color = 'var(--destructive-color)';
            }
        }
        rconCommandInput.addEventListener('keypress', function(event) { if (event.key === 'Enter') { event.preventDefault(); sendRconCommand(); } });

        async function handleInstanceAction(action, instanceName) {
            console.log(`handleInstanceAction: ${action}, ${instanceName}, Type: ${typeof instanceName}`);
            if (typeof instanceName !== 'string' || !instanceName) { 
                displayMessage('Fehler: Ungültiger Instanzname.', 'error'); 
                console.error("Ungültiger Instanzname:", instanceName); return; 
            }
            
            const button = document.querySelector(`.actions-cell button[onclick*="'${action}', '${instanceName}'"]`);
            if(button) button.disabled = true;

            let endpoint = ''; let confirmMessage1 = null; let confirmMessage2 = null; let method = 'POST'; let body = new FormData();

            switch(action) {
                case 'stop': endpoint = '/stop_server'; body.append('instance_name', instanceName); break;
                case 'restart': endpoint = '/restart_server'; body.append('instance_name', instanceName); break;
                case 'quick_start': endpoint = '/quick_start_server'; body.append('instance_name', instanceName); break;
                case 'delete':
                    endpoint = `/delete_instance/${instanceName}`;
                    confirmMessage1 = `Bist du SICHER, dass du die Instanz '${instanceName}' und ALLE ihre Dateien (Welt, Konfigs etc.) unwiderruflich löschen möchtest?\n\nDieser Vorgang kann NICHT rückgängig gemacht werden!`;
                    confirmMessage2 = `LETZTE WARNUNG für '${instanceName}'! Wirklich löschen?`;
                    if (!confirm(confirmMessage1) || !confirm(confirmMessage2)) { 
                        if(button) button.disabled = false; return; 
                    }
                    body = null; 
                    break;
                default: 
                    displayMessage('Unbekannte Aktion: ' + action, 'error'); 
                    if(button) button.disabled = false; return;
            }

            displayMessage(`Aktion '${action}' für '${instanceName}' wird ausgeführt...`, 'info');
            try {
                const fetchOptions = { method: method };
                if (body) fetchOptions.body = body;

                const response = await fetch(endpoint, fetchOptions);
                const result = await response.json();
                displayMessage(result.message, result.status);
            } catch (error) {
                displayMessage(`Netzwerkfehler bei Aktion '${action}': ${error.message}`, 'error');
            } finally {
                if(button && document.body.contains(button)) {
                    button.disabled = false;
                }
                refreshStatuses();
            }
        }

        async function refreshStatuses() {
            try {
                const response = await fetch('/server_status');
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                const statuses = await response.json();
                updateInstanceTable(statuses);
            } catch (error) {
                console.error("Fehler Serverstatus:", error);
                const tableBody = document.getElementById('instanceTableBody');
                if (!tableBody.querySelector('tr[data-instance-name]')) {
                    tableBody.innerHTML = `<tr><td colspan="4" class="message error" style="text-align:center;">Fehler Status: ${error.message}</td></tr>`;
                } else { 
                    displayMessage(`Status-Update fehlgeschlagen: ${error.message}`, 'warning'); 
                }
            }
        }

        function updateInstanceTable(statuses) {
            const tableBody = document.getElementById('instanceTableBody');
            const existingRows = new Map(Array.from(tableBody.querySelectorAll('tr[data-instance-name]')).map(row => [row.dataset.instanceName, row]));
            const currentInstanceNamesInStatus = new Set(Object.keys(statuses));
            
            const initialOrErrorRow = tableBody.querySelector('tr:not([data-instance-name])');
            if (initialOrErrorRow && Object.keys(statuses).length > 0) initialOrErrorRow.remove();

            if (Object.keys(statuses).length === 0 && !tableBody.querySelector('tr[data-instance-name]')) {
                 tableBody.innerHTML = `<tr><td colspan="4" style="text-align:center; padding: 30px; color: var(--text-color-tertiary);">Keine Instanzen konfiguriert oder gefunden.</td></tr>`;
                 return;
            }

            for (const instanceNameStr in statuses) {
                const data = statuses[instanceNameStr]; 
                let row = existingRows.get(instanceNameStr);
                if (!row) {
                    row = tableBody.insertRow(); row.dataset.instanceName = instanceNameStr;
                    row.insertCell().textContent = instanceNameStr; 
                    row.insertCell().className = 'status-cell';
                    row.insertCell().className = 'port-cell';    // NEU: Port Zelle
                    row.insertCell().className = 'actions-cell'; 
                    existingRows.set(instanceNameStr, row);
                }
                row.cells[1].textContent = data.status_text;
                row.cells[2].textContent = data.is_running_managed ? `${data.server_port}` : '-'; // Port anzeigen

                const actionCell = row.cells[3]; // Aktionen jetzt in Zelle 3
                actionCell.innerHTML = '';

                if (data.is_running_managed) {
                    actionCell.innerHTML += `<button class="action-btn destructive" onclick="handleInstanceAction('stop', '${instanceNameStr}')">Stop</button> `;
                    actionCell.innerHTML += `<button class="action-btn warning" onclick="handleInstanceAction('restart', '${instanceNameStr}')">Neustart</button> `;
                } else if (data.has_config) {
                    actionCell.innerHTML += `<button class="action-btn" onclick="handleInstanceAction('quick_start', '${instanceNameStr}')">Schnellstart</button> `;
                }
                if (data.log_exists) {
                    actionCell.innerHTML += `<button class="action-btn logs" onclick="openLogModal('${instanceNameStr}', ${data.rcon_available})">Logs</button> `;
                }
                actionCell.innerHTML += `<button class="action-btn destructive" onclick="handleInstanceAction('delete', '${instanceNameStr}')">Löschen</button>`;
            }
            existingRows.forEach((row, name) => { 
                if (!currentInstanceNamesInStatus.has(name)) row.remove(); 
            });
        }
        
        window.addEventListener('click', function(event) { if (event.target == logModal) closeLogModal(); });

    </script>
</body>
</html>